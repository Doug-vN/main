
// ensure this library description is only included once
#ifndef Communicative_h
#define Communicative_h

// include types & constants of Wiring core API
#include <Arduino.h>
#include "SPI_InstructionSet.h"
// library interface description

//!  A class to manage communication with slave module.
/*!
  This class is designed for SPI communication with a slave device. The class responsibilities
  include both SPI initialisation and fundamental transactions. The transaction protocol implemented
  follows the following flow: Clear SS -> Send '?' to slave -> recieve 'ACK' (0x06) from slave -> send request mCmd -> recieve sCmd/Data/Identity as expected -> set SS.
  Where mCmd, sCmd, Data and Identity are structures defined as types. 
*/
class Communicative
{
  // user-accessible "public" interface
  public:
    //! Constructor
    /*!
      Constructor initialises the SS pin to be used in communications and initialises SPI as Master.
      \param CS is the Slave Select pin designation; most commonly PA4.
      \sa SPISetup()
    */
    Communicative(const int CS);
    //! Destructor
    /*!
      Executes SPI.end();
    */
    ~Communicative(void);
    //! Checks whether Slave is connected.
    /*!
      Executes a nop transaction.
      \return true if handshake is successful and Slave responds to '?' with 'ACK'
      \sa areYouAlive()
    */
    bool isPeripheralConnected(void);
  
  //protected:  
    //! Performs a complete transaction; expects Slave to Reply with sCmd object.
    /*!
      Executes a complete transaction:  Clear SS -> Send '?' to slave -> recieve 'ACK' (0x06) from slave -> send request mCmd -> recieve sCmd -> set SS.
      \param mCmd is the mCmd object which constitutes the Request made to the slave. 
      \return The sCmd object generated by the Slave as the reply to the request.
      \sa RequestIdentity(), RequestData()
    */
    sCmd RequestReply(const mCmd);
    //! Performs a complete transaction; expects Slave to Reply with Identity object.
    /*!
      Executes a complete transaction:  Clear SS -> Send '?' to slave -> recieve 'ACK' (0x06) from slave -> send request mCmd -> recieve Identity -> set SS.
      \param mCmd is the mCmd object which constitutes the Request made to the slave. 
      \return The Idenity object generated by the Slave containing the Slave ID and name.
      \sa RequestReply(), RequestData()
    */
    Identity RequestIdentity(const mCmd);
    //! Performs a complete transaction; expects Slave to Reply with a Data object.
    /*!
      Executes a complete transaction:  Clear SS -> Send '?' to slave -> recieve 'ACK' (0x06) from slave -> send request mCmd -> recieve Data -> set SS.
      \param mCmd is the mCmd object which constitutes the Request made to the slave. 
      \return The Data object generated by the Slave containing a two dimensional array of data points and the length, headings and units of the data array rows.
      \sa RequestReply(), RequestIdentity()
    */
    Data RequestData(const mCmd);


  // library-accessible "private" interface
  private:
    //! Initialises Master SPI.
    /*!
      Initialises SPI1 to {MSBFirst,Mode0,ClockDiv16}
      \sa Communicative()
    */
    void SPISetup(void);
    //! Fundamental byte transfer over SPI
    /*!
      Executes SPI.transfer() and delays for a short time to allow Slave time to load reply into its Tx register as needed.
      \param byte is the 8 bit data packet to be sent to the Slave over MOSI
      \return the byte recieved from the slave over MISO
      \sa RequestReply(), RequestData(),RequestIdentity()
    */
    byte transferAndPause(const byte);
    //! Template function to send an object of any type over SPI
    /*!
      Sends any object over SPI by instantiating a pointer to the first byte of said object and then iterating said pointer
      through the memory domain of the object, for the size of objects of that type, calling transferAndPause() for each byte.
      NOTE: Requires the slave to be aware of the type of object to be recieved upon initiation of the communication, as the object
      must be reassembled, byte by byte, upon reception.
      \param value is the object of arbitrary type to be sent over SPI. 
      \return zero if the function failes.
      \sa transferAndPause()
    */
    template <typename T> unsigned int SPI_write (const T& value);
    //! Template function to recieve an object of any type over SPI
    /*!
      Recieves any object over SPI by instantiating a pointer to the first byte of an object of the same type already instatiated in memory,
      and iterating through each byte of said object, overwriting each byte with the bytes recived over SPI from calls to transferAndPause().
      NOTE: The type being recieved must be the same as the type of the local object. 
      \param value is the object of arbitrary type which is being overwritten by the object of the same type being recieved. 
      \return zero if the function failes.
      \sa transferAndPause()
    */
    template <typename T> unsigned int SPI_read(T& value);
    //! Executes a NOP transaction to check whether slave is connected
    /*! Executes complete transaction but used a request which is ensured to not change Slave state and can thus be treated as a nop 
      \return The byte send by the slave during the 'handshake' in reply to the '?' sent by master.
      \sa RequestReply(), RequestData(),RequestIdentity()
    */
    byte areYouAlive();

    int ChipSelect;
   // Identity ThisSensor;
};

#endif
